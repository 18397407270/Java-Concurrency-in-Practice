# Java内存模型

<!-- TOC -->

- [Java内存模型](#java内存模型)
    - [Java内存间的操作](#java内存间的操作)
    - [Java内存模型中的8个原子操作](#java内存模型中的8个原子操作)
    - [Java内存模型规定在执行上述8个操作时的规则](#java内存模型规定在执行上述8个操作时的规则)
        - [有关变量拷贝过程的规则](#有关变量拷贝过程的规则)
        - [有关加锁的规则](#有关加锁的规则)
    - [原子性、可见性与有序性](#原子性可见性与有序性)
        - [原子性](#原子性)
        - [可见性](#可见性)
        - [有序性](#有序性)

<!-- /TOC -->

## Java内存间的操作

Java中，线程、工作内存、主内存三者的交互关系如下：

![Java内存间的操作.png](./pic/Java内存间的操作.png)

通过上图可以发现，Java线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。即使是volatile变量，也是从工作内存中读取的，只是它有特殊的操作顺序规定，使得看起来像是直接在主内存中读写。

**一个变量从主内存拷贝到工作内存，再从工作内存同步回主内存的过程：**

```
|主内存| -> read -> load -> |工作内存| -> user -> |Java线程| -> assign -> |工作内存| -> store -> write -> |主内存|
```

> 注意：read和load，store和write不一定是连续执行的，中间可以插入其他命令

## Java内存模型中的8个原子操作

- `lock`：作用于主内存，把一个变量标识为一个线程独占状态。
- `unlock`：作用于主内存，释放一个处于锁定状态的变量。
- `read`：作用于主内存，把一个变量的值从主内存传输到线程工作内存中，供之后的load操作使用。
- `load`：作用于工作内存，把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- `use`：作用于工作内存，把工作内存中的一个变量传递给执行引擎，虚拟机遇到使用变量值的字节码指令时会执行。
- `assign`：作用于工作内存，把一个从执行引擎得到的值赋给工作内存的变量，虚拟机遇到给变量赋值的字节码指令时会执行。
- `store`：作用于工作内存，把工作内存中的一个变量传送到主内存中，供之后的write操作使用。
- `write`：作用于主内存，把store操作从工作内存中得到的变量值存入主内存的变量中。


## Java内存模型规定在执行上述8个操作时的规则

### 有关变量拷贝过程的规则

- 不允许read和load，store和write单独出现
- 不允许线程丢弃它最近的assign操作，即工作内存变化之后必须把该变化同步回主内存中
- 不允许一个线程在没有assign的情况下将工作内存同步回主内存中
- 新的变量只能从主内存中诞生，即不能在工作内存中使用未被load和assign的变量，一个变量在use和store前一定先经过了load和assign

### 有关加锁的规则

- 一个变量在同一时刻只允许一个线程对其进行lock操作，但是可以被一个线程多次lock（锁的可重入）
- 对一个变量进行lock操作会清空这个变量在工作内存中的值，然后在执行引擎使用这个变量时，需要通过assign或load重新对这个变量进行初始化
- 对一个变量执行unlock前，必须将该变量同步回主内存中，即执行store和write操作
- 一个变量没有被lock，就不能被unlock，也不能去unlock一个被其他线程lock的变量


## 原子性、可见性与有序性

### 原子性

- 给用户提供了字节码指令：monitorenter和monitorexit来隐式的使用lock和unlock。
- 这两个字节码反映到Java代码中就是同步块：synchronized。

### 可见性

- 当一条线程修改了共享变量的值，其他线程可以立即得知这个修改。
- 实现方式：在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的方式实现，依赖主内存作为传输媒质。
- 可以保证可见性的关键字：
  - `volatile`：通过volatile的特殊规则；
  - `synchronized`：通过“对一个变量执行unlock操作前，必须将该变量同步回主内存”这条规则。
  - `final`：被final修饰的字段，一旦完成了初始化，其他线程就能看到它，并且它也不会再变了。
    - 即只要不可变对象被正确的构建出来（没有发生this引用溢出），它就是线程安全的。

### 有序性

- 如果在本线程内观察，所有操作都是有序的。
  - 即Java内存模型会保证重排序后的执行，在线程内看起来和串行的效果是一样的。
- 如果在一个线程观察另一个线程，所有操作都是无序的。
- 可以保证有序性的关键字：
  - volatile：本身禁止指令重排序；
  - synchronized：通过保证线程的串行执行来保证有序性，因为“线程内表现为串行的语义”。
