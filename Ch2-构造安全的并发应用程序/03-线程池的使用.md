# 线程池的使用

[TOC]

## 为什么要使用线程池

**我们希望应用程序是这样的：**

- 在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性；
- 当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败。

**如果不使用线程池，为每一个任务都创建一个线程来执行，我们将会遇到如下问题：**

- 线程的创建和销毁都需要时间，会延迟请求的处理，并且消耗系统资源；
	- 尤其是内存，还会增加 GC 的压力；同时在系统崩溃的临界点，如果多创建一个线程，就会导致系统崩溃，而不是性能的缓慢下降。
- 如果线程数超过了 CPU 数，增加线程反而会降低性能，因为会出现频繁的上下文切换。

**合理使用线程池的好处：**

- 降低资源消耗：可以重复使用已经创建好的线程
- 提高响应速度：任务到达时，可以不需要等待线程创建的时间
- 提高线程的可管理性

## Executor框架概述

通过 Executor 框架，我们可以将工作单元（Runnable & Callable）与执行机制（Executor）分离，即**将任务的提交和任务的执行分离**。

### Executor 框架主要由 3 大部分组成

- **任务：** 实现接口：Runnable 接口或 Callable 接口。

- **任务的执行：** 包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 ExecutorService 接口。

- - Executor 框架有两个关键类实现了 ExecutorService 接口

	- - ThreadPoolExecutor
		- ScheduledThreadPoolExecutor

- **异步计算的结果** ：接口 Future 和实现 Future 接口的 FutureTask 类。

### Executor 是基于生产者 -- 消费者模式的

- 提交任务的操作相当于生产者（生成待完成的工作单元）
- 执行任务的线程则相当于消费者（执行完这些工作单元）

### Executor框架的主要类和接口

**Executor 接口：** 框架的基础，线程池都是实现自它的子接口的。

```java
public interface Executor {
    void execute(Runnable command);
}
```

![Executor框架的主要类和接口.png](https://github.com/TangBean/Java-Concurrency-in-Practice/blob/master/Ch2-%E6%9E%84%E9%80%A0%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/Pic/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.png)

**Executor框架的主要成员：**

- ThreadPoolExecutor
- ScheduledThreadPoolExecutor
- Future 接口 & FutureTask 实现类
- Runnable 接口 & Callable 接口
- Executors 工厂类

接下来，我们将一一介绍这些 Executor 框架的组件。在介绍这些组件之前，我们先来看一下线程池要如何使用。

## 线程池的基本使用方法







## ThreadPoolExecutor

ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。一般通过 Executors 工具类创建，我们可以通过 Executor 创建如下三种 ThreadPoolExecutor：

- FixedThreadPool
- CacheThreadPool
- SingleThreadExecutor

接下来我们将分别介绍它们。

首先，我们需要介绍一下 ThreadPoolExecutor 的构造方法，因为以上三种 ThreadPoolExecutor 其实都是被赋予了不同的构造参数的 ThreadPoolExecutor 对象。

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) { ... }
```

**参数说明：**

| 参数                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| corePoolSize             | 核心线程池大小，即没有执行任务时的线程池大小，只有在工作队列满了的情况下才会创建超出这个数量的线程 |
| maximumPoolSize          | 最大线程池的大小                                             |
| keepAliveTime            | 某个线程的空闲时间超过了存活时间，那么将被标记为可回收的     |
| BlockingQueue            | 用来暂时保存任务的工作队列                                   |
| RejectedExecutionHandler | 当 ThreadPoolExecutor 已经关闭或者达到了最大线程池大小并且工作队列已满时，调用 execute() 方法会调用 RejectedExecutionHandler handler |

### FixedThreadPool

**特点：** 固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，如果某个线程由于发生了未预期的 Exception 而结束，那么线程池会补充一个新的线程。

**创建方法：**

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,  // 线程池大小不可扩展
                                  0L, TimeUnit.MILLISECONDS,  // 多余线程会被立即终止
                                  new LinkedBlockingQueue<Runnable>());  
    							// 使用容量为 Integer.MAX_VALUE 的工作队列
    							// 由于使用了无界队列，不会拒绝任务，所以不会调用 handler
}
```



### CacheThreadPool

**特点：** 可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。

**创建方法：**

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  // 初始为0，线程池中的线程数是无界的
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());  
}
```

> **注意：**
>
> - 池中不会有空闲线程，也不会有等待的线程
> - 一旦任务到达的速度大于线程池处理任务的速度，就会创建一个新的线程给任务
> - 与另外两个线程池不同的地方在于，这个工作队列并不是用来放还没有执行的任务的，而是用来放执行过任务后空闲下的线程的，空闲下来的线程会被：`SynchronousQueue#poll(keepAliveTime, TimeUnit.NANOSECONDS)` poll 到工作队列中等待 60s，如果这 60s 有新的任务到达了，这个线程就被派出去执行任务，如果没有，就销毁。

### SingleThreadPool

**特点：** 单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。能确保依照任务在队列中的顺序来串行执行。

**创建方法：**

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,  // 线程池的大小固定为1
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
    						  // 使用容量为 Integer.MAX_VALUE 的工作队列
}
```

### Remarks

- 在创建 ThreadPoolExecutor 初期，线程并不会立即启动，而是等到有任务提交时才会启动，除非调用 prestartAllCoreThreads
- 将线程池的 corePoolSize 设置为 0 且不使用 SynchronousQueue 作为工作队列会产生的奇怪行为：只有当线程池的工作队列被填满后，才会开始执行任务
	- 产生原因：如果线程池中的线程数量等于线程池的基本大小，那么仅当在工作队列已满的情况下ThreadPoolExecutor才会创建新的线程，如果线程池的基本大小为零并且其工作队列有一定的容量，那么当把任务提交给该线程池时，**只有当线程池的工作队列被填满后，才会开始执行任务，因为这个时候才会创建新的线程，在此之前，线程池只有在工作队列中等待任务，没有执行任务的线程。**

### ScheduledThreadPoolExecutor

可以在给定的延迟后运行命令，或者定期执行命令。比 Timer 更灵活，功能更强大。



## Future 接口 & FutureTask 实现类





## Runnable 接口 & Callable 接口





## Executors 工厂类





## 设置线程池的大小

### 线程池过大过小的缺点

- 过大
	- 大量线程将在很少的 CPU 资源上发生竞争
	- 大量空闲线程会耗费内存，导致资源耗尽
- 过小
	- CPU 闲置，系统吞吐率下降

### 线程池大小的设置

- **计算密集型任务：**N = N_cpu + 1
	- 加 1 的原因：当有一个线程偶尔故障时，额外的那个线程可以立即补上，保证CPU时钟不会被浪费
- **包含I/O或其他阻塞操作：**N = N_cpu * U_cpu * (1 + W / C)
	- N_cpu：CPU 的个数
	- U_cpu：目标 CPU 利用率
	- W / C：等待时间 (Wait) / 计算时间 (Compute)
	- 获取 CPU 数目的方法：`int N_CPUS = Runtime.getRuntime().availableProcessors();`

